{"id":"a29a69a9-4123-4e2d-afe7-f322334333fb","zed":"context","version":"0.4.0","text":"\n\n\n```zig /home/msharran/.cache/zig/p/12205b2b47fe61a4cde3a45ee4b9cddee75897739dbc196d6396e117cb1ce28e1ad0/src/watcher/tcp.zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst assert = std.debug.assert;\nconst posix = std.posix;\nconst stream = @import(\"stream.zig\");\nconst common = @import(\"common.zig\");\n\n/// TCP client and server.\n///\n/// This is a \"higher-level abstraction\" in libxev. The goal of higher-level\n/// abstractions in libxev are to make it easier to use specific functionality\n/// with the event loop, but does not promise perfect flexibility or optimal\n/// performance. In almost all cases, the abstraction is good enough. But,\n/// if you have specific needs or want to push for the most optimal performance,\n/// use the platform-specific Loop directly.\npub fn TCP(comptime xev: type) type {\n    return struct {\n        const Self = @This();\n        const FdType = if (xev.backend == .iocp) std.os.windows.HANDLE else posix.socket_t;\n\n        fd: FdType,\n\n        pub usingnamespace stream.Stream(xev, Self, .{\n            .close = true,\n            .read = .recv,\n            .write = .send,\n        });\n\n        /// Initialize a new TCP with the family from the given address. Only\n        /// the family is used, the actual address has no impact on the created\n        /// resource.\n        pub fn init(addr: std.net.Address) !Self {\n            if (xev.backend == .wasi_poll) @compileError(\"unsupported in WASI\");\n\n            const fd = if (xev.backend == .iocp)\n                try std.os.windows.WSASocketW(addr.any.family, posix.SOCK.STREAM, 0, null, 0, std.os.windows.ws2_32.WSA_FLAG_OVERLAPPED)\n            else fd: {\n                // On io_uring we don't use non-blocking sockets because we may\n                // just get EAGAIN over and over from completions.\n                const flags = flags: {\n                    var flags: u32 = posix.SOCK.STREAM | posix.SOCK.CLOEXEC;\n                    if (xev.backend != .io_uring) flags |= posix.SOCK.NONBLOCK;\n                    break :flags flags;\n                };\n                break :fd try posix.socket(addr.any.family, flags, 0);\n            };\n\n            return .{\n                .fd = fd,\n            };\n        }\n\n        /// Initialize a TCP socket from a file descriptor.\n        pub fn initFd(fd: FdType) Self {\n            return .{\n                .fd = fd,\n            };\n        }\n\n        /// Bind the address to the socket.\n        pub fn bind(self: Self, addr: std.net.Address) !void {\n            if (xev.backend == .wasi_poll) @compileError(\"unsupported in WASI\");\n\n            const fd = if (xev.backend == .iocp) @as(std.os.windows.ws2_32.SOCKET, @ptrCast(self.fd)) else self.fd;\n\n            try posix.setsockopt(fd, posix.SOL.SOCKET, posix.SO.REUSEADDR, &std.mem.toBytes(@as(c_int, 1)));\n            try posix.bind(fd, &addr.any, addr.getOsSockLen());\n        }\n\n        /// Listen for connections on the socket. This puts the socket into passive\n        /// listening mode. Connections must still be accepted one at a time.\n        pub fn listen(self: Self, backlog: u31) !void {\n            if (xev.backend == .wasi_poll) @compileError(\"unsupported in WASI\");\n\n            const fd = if (xev.backend == .iocp) @as(std.os.windows.ws2_32.SOCKET, @ptrCast(self.fd)) else self.fd;\n\n            try posix.listen(fd, backlog);\n        }\n\n        /// Accept a single connection.\n        pub fn accept(\n            self: Self,\n            loop: *xev.Loop,\n            c: *xev.Completion,\n            comptime Userdata: type,\n            userdata: ?*Userdata,\n            comptime cb: *const fn (\n                ud: ?*Userdata,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                r: AcceptError!Self,\n            ) xev.CallbackAction,\n        ) void {\n            c.* = .{\n                .op = .{\n                    .accept = .{\n                        .socket = self.fd,\n                    },\n                },\n\n                .userdata = userdata,\n                .callback = (struct {\n                    fn callback(\n                        ud: ?*anyopaque,\n                        l_inner: *xev.Loop,\n                        c_inner: *xev.Completion,\n                        r: xev.Result,\n                    ) xev.CallbackAction {\n                        return @call(.always_inline, cb, .{\n                            common.userdataValue(Userdata, ud),\n                            l_inner,\n                            c_inner,\n                            if (r.accept) |fd| initFd(fd) else |err| err,\n                        });\n                    }\n                }).callback,\n            };\n\n            // If we're dup-ing, then we ask the backend to manage the fd.\n            switch (xev.backend) {\n                .io_uring,\n                .kqueue,\n                .wasi_poll,\n                .iocp,\n                => {},\n\n                .epoll => c.flags.dup = true,\n            }\n\n            loop.add(c);\n        }\n\n        /// Establish a connection as a client.\n        pub fn connect(\n            self: Self,\n            loop: *xev.Loop,\n            c: *xev.Completion,\n            addr: std.net.Address,\n            comptime Userdata: type,\n            userdata: ?*Userdata,\n            comptime cb: *const fn (\n                ud: ?*Userdata,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: Self,\n                r: ConnectError!void,\n            ) xev.CallbackAction,\n        ) void {\n            if (xev.backend == .wasi_poll) @compileError(\"unsupported in WASI\");\n\n            c.* = .{\n                .op = .{\n                    .connect = .{\n                        .socket = self.fd,\n                        .addr = addr,\n                    },\n                },\n\n                .userdata = userdata,\n                .callback = (struct {\n                    fn callback(\n                        ud: ?*anyopaque,\n                        l_inner: *xev.Loop,\n                        c_inner: *xev.Completion,\n                        r: xev.Result,\n                    ) xev.CallbackAction {\n                        return @call(.always_inline, cb, .{\n                            common.userdataValue(Userdata, ud),\n                            l_inner,\n                            c_inner,\n                            initFd(c_inner.op.connect.socket),\n                            if (r.connect) |_| {} else |err| err,\n                        });\n                    }\n                }).callback,\n            };\n\n            loop.add(c);\n        }\n\n        /// Shutdown the socket. This always only shuts down the writer side. You\n        /// can use the lower level interface directly to control this if the\n        /// platform supports it.\n        pub fn shutdown(\n            self: Self,\n            loop: *xev.Loop,\n            c: *xev.Completion,\n            comptime Userdata: type,\n            userdata: ?*Userdata,\n            comptime cb: *const fn (\n                ud: ?*Userdata,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: Self,\n                r: ShutdownError!void,\n            ) xev.CallbackAction,\n        ) void {\n            c.* = .{\n                .op = .{\n                    .shutdown = .{\n                        .socket = self.fd,\n                        .how = .send,\n                    },\n                },\n                .userdata = userdata,\n                .callback = (struct {\n                    fn callback(\n                        ud: ?*anyopaque,\n                        l_inner: *xev.Loop,\n                        c_inner: *xev.Completion,\n                        r: xev.Result,\n                    ) xev.CallbackAction {\n                        return @call(.always_inline, cb, .{\n                            common.userdataValue(Userdata, ud),\n                            l_inner,\n                            c_inner,\n                            initFd(c_inner.op.shutdown.socket),\n                            if (r.shutdown) |_| {} else |err| err,\n                        });\n                    }\n                }).callback,\n            };\n\n            loop.add(c);\n        }\n\n        pub const AcceptError = xev.AcceptError;\n        pub const ConnectError = xev.ConnectError;\n        pub const ShutdownError = xev.ShutdownError;\n\n        test \"TCP: accept/connect/send/recv/close\" {\n            // We have no way to get a socket in WASI from a WASI context.\n            if (xev.backend == .wasi_poll) return error.SkipZigTest;\n\n            const testing = std.testing;\n\n            var loop = try xev.Loop.init(.{});\n            defer loop.deinit();\n\n            // Choose random available port (Zig #14907)\n            var address = try std.net.Address.parseIp4(\"127.0.0.1\", 0);\n            const server = try Self.init(address);\n\n            // Bind and listen\n            try server.bind(address);\n            try server.listen(1);\n\n            // Retrieve bound port and initialize client\n            var sock_len = address.getOsSockLen();\n            const fd = if (xev.backend == .iocp) @as(std.os.windows.ws2_32.SOCKET, @ptrCast(server.fd)) else server.fd;\n            try posix.getsockname(fd, &address.any, &sock_len);\n            const client = try Self.init(address);\n\n            //const address = try std.net.Address.parseIp4(\"127.0.0.1\", 3132);\n            //var server = try Self.init(address);\n            //var client = try Self.init(address);\n\n            // Completions we need\n            var c_accept: xev.Completion = undefined;\n            var c_connect: xev.Completion = undefined;\n\n            // Accept\n            var server_conn: ?Self = null;\n            server.accept(&loop, &c_accept, ?Self, &server_conn, (struct {\n                fn callback(\n                    ud: ?*?Self,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    r: AcceptError!Self,\n                ) xev.CallbackAction {\n                    ud.?.* = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Connect\n            var connected: bool = false;\n            client.connect(&loop, &c_connect, address, bool, &connected, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: ConnectError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = true;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Wait for the connection to be established\n            try loop.run(.until_done);\n            try testing.expect(server_conn != null);\n            try testing.expect(connected);\n\n            // Close the server\n            var server_closed = false;\n            server.close(&loop, &c_accept, bool, &server_closed, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = true;\n                    return .disarm;\n                }\n            }).callback);\n            try loop.run(.until_done);\n            try testing.expect(server_closed);\n\n            // Send\n            var send_buf = [_]u8{ 1, 1, 2, 3, 5, 8, 13 };\n            client.write(&loop, &c_connect, .{ .slice = &send_buf }, void, null, (struct {\n                fn callback(\n                    _: ?*void,\n                    _: *xev.Loop,\n                    c: *xev.Completion,\n                    _: Self,\n                    _: xev.WriteBuffer,\n                    r: Self.WriteError!usize,\n                ) xev.CallbackAction {\n                    _ = c;\n                    _ = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Receive\n            var recv_buf: [128]u8 = undefined;\n            var recv_len: usize = 0;\n            server_conn.?.read(&loop, &c_accept, .{ .slice = &recv_buf }, usize, &recv_len, (struct {\n                fn callback(\n                    ud: ?*usize,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    _: xev.ReadBuffer,\n                    r: Self.ReadError!usize,\n                ) xev.CallbackAction {\n                    ud.?.* = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Wait for the send/receive\n            try loop.run(.until_done);\n            try testing.expectEqualSlices(u8, &send_buf, recv_buf[0..recv_len]);\n\n            // Close\n            server_conn.?.close(&loop, &c_accept, ?Self, &server_conn, (struct {\n                fn callback(\n                    ud: ?*?Self,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = null;\n                    return .disarm;\n                }\n            }).callback);\n            client.close(&loop, &c_connect, bool, &connected, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = false;\n                    return .disarm;\n                }\n            }).callback);\n\n            try loop.run(.until_done);\n            try testing.expect(server_conn == null);\n            try testing.expect(!connected);\n            try testing.expect(server_closed);\n        }\n\n        // Potentially flaky - this test could hang if the sender is unable to\n        // write everything to the socket for whatever reason\n        // (e.g. incorrectly sized buffer on the receiver side), or if the\n        // receiver is trying to receive while sender has nothing left to send.\n        //\n        // Overview:\n        // 1. Set up server and client sockets\n        // 2. connect & accept, set SO_SNDBUF to 8kB on the client\n        // 3. Try to send 1MB buffer from client to server without queuing, this _should_ fail\n        //    and theoretically send <= 8kB, but in practice, it seems to write ~32kB.\n        //    Asserts that <= 100kB was written\n        // 4. Set up a queued write with the remaining buffer, shutdown() the socket afterwards\n        // 5. Set up a receiver that loops until it receives the entire buffer\n        // 6. Assert send_buf == recv_buf\n        test \"TCP: Queued writes\" {\n            // We have no way to get a socket in WASI from a WASI context.\n            if (xev.backend == .wasi_poll) return error.SkipZigTest;\n            // Windows doesn't seem to respect the SNDBUF socket option.\n            if (builtin.os.tag == .windows) return error.SkipZigTest;\n\n            const testing = std.testing;\n\n            var loop = try xev.Loop.init(.{});\n            defer loop.deinit();\n\n            // Choose random available port (Zig #14907)\n            var address = try std.net.Address.parseIp4(\"127.0.0.1\", 0);\n            const server = try Self.init(address);\n\n            // Bind and listen\n            try server.bind(address);\n            try server.listen(1);\n\n            // Retrieve bound port and initialize client\n            var sock_len = address.getOsSockLen();\n            try posix.getsockname(server.fd, &address.any, &sock_len);\n            const client = try Self.init(address);\n\n            // Completions we need\n            var c_accept: xev.Completion = undefined;\n            var c_connect: xev.Completion = undefined;\n\n            // Accept\n            var server_conn: ?Self = null;\n            server.accept(&loop, &c_accept, ?Self, &server_conn, (struct {\n                fn callback(\n                    ud: ?*?Self,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    r: AcceptError!Self,\n                ) xev.CallbackAction {\n                    ud.?.* = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Connect\n            var connected: bool = false;\n            client.connect(&loop, &c_connect, address, bool, &connected, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: ConnectError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = true;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Wait for the connection to be established\n            try loop.run(.until_done);\n            try testing.expect(server_conn != null);\n            try testing.expect(connected);\n\n            // Close the server\n            var server_closed = false;\n            server.close(&loop, &c_accept, bool, &server_closed, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = true;\n                    return .disarm;\n                }\n            }).callback);\n            try loop.run(.until_done);\n            try testing.expect(server_closed);\n\n            // Unqueued send - Limit send buffer to 8kB, this should force partial writes.\n            try posix.setsockopt(client.fd, posix.SOL.SOCKET, posix.SO.SNDBUF, &std.mem.toBytes(@as(c_int, 8192)));\n\n            const send_buf = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 } ** 100_000;\n            var sent_unqueued: usize = 0;\n\n            // First we try to send the whole 1MB buffer in one write operation, this _should_ result\n            // in a partial write.\n            client.write(&loop, &c_connect, .{ .slice = &send_buf }, usize, &sent_unqueued, (struct {\n                fn callback(\n                    sent_unqueued_inner: ?*usize,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    _: xev.WriteBuffer,\n                    r: Self.WriteError!usize,\n                ) xev.CallbackAction {\n                    sent_unqueued_inner.?.* = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Make sure that we sent a small fraction of the buffer\n            try loop.run(.until_done);\n            // SO_SNDBUF doesn't seem to be respected exactly, sent_unqueued will often be ~32kB\n            // even though SO_SNDBUF was set to 8kB\n            try testing.expect(sent_unqueued < (send_buf.len / 10));\n\n            // Set up queued write\n            var w_queue = Self.WriteQueue{};\n            var wr_send: xev.TCP.WriteRequest = undefined;\n            var sent_queued: usize = 0;\n            const queued_slice = send_buf[sent_unqueued..];\n            client.queueWrite(&loop, &w_queue, &wr_send, .{ .slice = queued_slice }, usize, &sent_queued, (struct {\n                fn callback(\n                    sent_queued_inner: ?*usize,\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    tcp: Self,\n                    _: xev.WriteBuffer,\n                    r: Self.WriteError!usize,\n                ) xev.CallbackAction {\n                    sent_queued_inner.?.* = r catch unreachable;\n\n                    tcp.shutdown(l, c, void, null, (struct {\n                        fn callback(\n                            _: ?*void,\n                            _: *xev.Loop,\n                            _: *xev.Completion,\n                            _: Self,\n                            _: Self.ShutdownError!void,\n                        ) xev.CallbackAction {\n                            return .disarm;\n                        }\n                    }).callback);\n\n                    return .disarm;\n                }\n            }).callback);\n\n            // Set up receiver which is going to keep reading until it reads the full\n            // send buffer\n            const Receiver = struct {\n                loop: *xev.Loop,\n                conn: Self,\n                completion: xev.Completion = .{},\n                buf: [send_buf.len]u8 = undefined,\n                bytes_read: usize = 0,\n\n                pub fn read(receiver: *@This()) void {\n                    if (receiver.bytes_read == receiver.buf.len) return;\n\n                    const read_buf = xev.ReadBuffer{\n                        .slice = receiver.buf[receiver.bytes_read..],\n                    };\n                    receiver.conn.read(receiver.loop, &receiver.completion, read_buf, @This(), receiver, readCb);\n                }\n\n                pub fn readCb(\n                    receiver_opt: ?*@This(),\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    _: xev.ReadBuffer,\n                    r: Self.ReadError!usize,\n                ) xev.CallbackAction {\n                    var receiver = receiver_opt.?;\n                    const n_bytes = r catch unreachable;\n\n                    receiver.bytes_read += n_bytes;\n                    if (receiver.bytes_read < send_buf.len) {\n                        receiver.read();\n                    }\n\n                    return .disarm;\n                }\n            };\n            var receiver = Receiver{\n                .loop = &loop,\n                .conn = server_conn.?,\n            };\n            receiver.read();\n\n            // Wait for the send/receive\n            try loop.run(.until_done);\n            try testing.expectEqualSlices(u8, &send_buf, receiver.buf[0..receiver.bytes_read]);\n            try testing.expect(send_buf.len == sent_unqueued + sent_queued);\n\n            // Close\n            server_conn.?.close(&loop, &c_accept, ?Self, &server_conn, (struct {\n                fn callback(\n                    ud: ?*?Self,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = null;\n                    return .disarm;\n                }\n            }).callback);\n            client.close(&loop, &c_connect, bool, &connected, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = false;\n                    return .disarm;\n                }\n            }).callback);\n\n            try loop.run(.until_done);\n            try testing.expect(server_conn == null);\n            try testing.expect(!connected);\n            try testing.expect(server_closed);\n        }\n    };\n}\n```\n\n```zig zig-redis-server/src/Server.zig\nconst std = @import(\"std\");\nconst log = std.log.scoped(.server);\nconst net = std.net;\nconst posix = std.posix;\n\nconst Server = @This();\nconst Dictionary = @import(\"Dictionary.zig\");\nconst Router = @import(\"Router.zig\");\nconst Resp = @import(\"Resp.zig\");\nconst Request = @import(\"command.zig\").Request;\nconst ThreadPool = std.Thread.Pool;\nconst xev = @import(\"xev\");\nconst TCP = xev.TCP;\n\n/// router is responsible for handling the commands received by the server.\nrouter: Router,\n\n/// allocator is used to allocate memory for the server.\nallocator: std.mem.Allocator,\n\ndict: *Dictionary,\n\n/// pool is used to handle incoming connections concurrently.\npool: *ThreadPool,\n\n/// init allocates memory for the server.\n/// Caller should call self.deinit to free the memory.\npub fn init(allocator: std.mem.Allocator) !Server {\n    const obj_store = try Dictionary.init(allocator);\n    const router = try Router.init(allocator);\n\n    const opt = ThreadPool.Options{\n        .n_jobs = 4, // TODO: Make this configurable\n        .allocator = allocator,\n    };\n    var pool = try allocator.create(ThreadPool);\n    try pool.init(opt);\n\n    return Server{\n        .allocator = allocator,\n        .router = router,\n        .dict = obj_store,\n        .pool = pool,\n    };\n}\n\npub fn deinit(self: *Server) void {\n    defer std.debug.print(\"Server deinitialised\", .{});\n\n    self.pool.deinit();\n    self.allocator.destroy(self.pool);\n    self.dict.deinit();\n    self.router.deinit();\n    self.* = undefined;\n}\n\npub fn listenAndServe(self: *Server, address: std.net.Address) !void {\n    var loop = try xev.Loop.init(.{});\n    defer loop.deinit();\n\n    // Initialize TCP server\n    const server = try TCP.init(address);\n\n    // Bind and listen\n    try server.bind(address);\n    try server.listen(128);\n\n    // Completion for accept\n    var accept_completion: xev.Completion = undefined;\n\n    const s: ?*Server = self;\n\n    // Accept loop\n    while (true) {\n        server.accept(\n            &loop,\n            &accept_completion,\n            Server,\n            s,\n            (struct {\n                fn callback(\n                    srv: ?*Server,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    result: TCP.AcceptError!TCP,\n                ) xev.CallbackAction {\n                    const connection = result catch |err| {\n                        log.err(\"Accept error, rearming accept handler: {}\", .{err});\n                        return .rearm;\n                    };\n\n                    // Handle the new connection\n                    handleConnection(srv.?, connection) catch |err| {\n                        log.err(\"Connection handling error: {}\", .{err});\n                    };\n\n                    return .rearm;\n                }\n            }).callback,\n        );\n\n        // Run the event loop\n        try loop.run(.until_done);\n    }\n}\n\nconst Connection = struct {\n    server: *Server,\n    tcp: *TCP,\n    loop: *xev.Loop,\n    \n     \n};\n\nfn enqueueConnection(self: *Server, connection: TCP, loop: xev.Loop) void {\n    const resp = Resp.init(self.allocator);\n    defer resp.deinit();\n\n    var read_buf: [4028]u8 = undefined;\n    var read_len: ?usize = null;\n    var c_read: xev.Completion = undefined;\n\n    // Set up read completion\n    connection.read(loop, &c_read, .{ .slice = &read_buf }, usize, &read_len, (struct {\n        fn callback(\n            read_len_ptr: *?usize,\n            l: *xev.Loop,\n            c: *xev.Completion,\n            _: TCP,\n            r_buf: xev.ReadBuffer,\n            r_buf_len: TCP.ReadError!usize,\n        ) xev.CallbackAction {\n            read_len_ptr.?.* = r_buf_len catch |err| {\n                log.err(\"Failed to read from client: {}\", .{err});\n                return .disarm;\n            };\n\n            const msg = resp.deserialise(r_buf.slice[0..r_buf_len]) catch |err| {\n                log.err(\"Failed to deserialise message: {}\", .{err});\n                return .disarm;\n            };\n\n            const req = Request{ .message = msg, .dict = self.dict };\n            const resp_msg = self.router.route(req);\n            const raw_msg = resp.serialise(resp_msg) catch |err| {\n                log.err(\"Failed to serialise message: {}\", .{err});\n                return .disarm;\n            };\n\n            connection.write(raw_msg) catch |err| {\n                log.err(\"Failed to write to client: {}\", .{err});\n            };\n            return .disarm;\n        }\n    }).callback);\n}\n\n/// handleConnection is reponsible for handling incoming connections.\n/// It reads from the client, deserialises the message, routes it to the appropriate handler,\n/// and writes the response back to the client.\n///\n/// Arguments:\n///     self: The server instance\n///     connection: The socket file descriptor for the client connection\n///\n/// Returns: void\nfn handleConnection(self: *Server, connection: posix.socket_t) void {\n    defer posix.close(connection);\n\n    var buf: [4028]u8 = undefined;\n    const read = posix.read(connection, &buf) catch |err| {\n        log.err(\"Failed to read from client: {}\", .{err});\n        return;\n    };\n\n    if (read == 0) {\n        log.info(\"Read 0 bytes from client, closing connection\", .{});\n        return;\n    }\n\n    const resp = Resp.init(self.allocator);\n    defer resp.deinit();\n\n    const msg = resp.deserialise(buf[0..read]) catch |err| {\n        log.err(\"Failed to deserialise message: {}\", .{err});\n        return;\n    };\n\n    const req = Request{ .message = msg, .dict = self.dict };\n    const resp_msg = self.router.route(req);\n\n    const raw_msg = resp.serialise(resp_msg) catch |err| {\n        log.err(\"Failed to serialise message: {}\", .{err});\n        return;\n    };\n\n    writeAll(connection, raw_msg) catch |err| {\n        log.err(\"Failed to write to client: {}\", .{err});\n    };\n}\n\nfn writeAll(socket: posix.socket_t, msg: []const u8) !void {\n    var pos: usize = 0;\n    while (pos < msg.len) {\n        const written = try posix.write(socket, msg[pos..]);\n        if (written == 0) {\n            return error.Closed;\n        }\n        pos += written;\n    }\n}\n```\n\n\ngenerate wrapper functions for accept, read and write\nfor Connection struct wrapping xev.TCP functions\n\nI'll help you create wrapper functions for the Connection struct to handle TCP operations. Here's how we can implement these wrappers:\n\n```zig\nconst Connection = struct {\n    server: *Server,\n    tcp: TCP,\n    loop: *xev.Loop,\n    completion: xev.Completion = undefined,\n    buffer: [4096]u8 = undefined,\n\n    pub fn init(server: *Server, tcp: TCP, loop: *xev.Loop) Connection {\n        return .{\n            .server = server,\n            .tcp = tcp,\n            .loop = loop,\n        };\n    }\n\n    pub fn accept(\n        self: *Connection,\n        comptime Userdata: type,\n        userdata: ?*Userdata,\n        comptime callback: *const fn (\n            ud: ?*Userdata,\n            conn: *Connection,\n            r: TCP.AcceptError!TCP,\n        ) void,\n    ) void {\n        const Context = struct {\n            conn: *Connection,\n            inner_callback: *const fn (\n                ud: ?*Userdata,\n                conn: *Connection,\n                r: TCP.AcceptError!TCP,\n            ) void,\n            userdata: ?*Userdata,\n        };\n\n        const ctx = Context{\n            .conn = self,\n            .inner_callback = callback,\n            .userdata = userdata,\n        };\n\n        self.tcp.accept(\n            self.loop,\n            &self.completion,\n            Context,\n            &ctx,\n            (struct {\n                fn callback(\n                    context: ?*Context,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    result: TCP.AcceptError!TCP,\n                ) xev.CallbackAction {\n                    context.?.inner_callback(\n                        context.?.userdata,\n                        context.?.conn,\n                        result,\n                    );\n                    return .disarm;\n                }\n            }).callback,\n        );\n    }\n\n    pub fn read(\n        self: *Connection,\n        comptime Userdata: type,\n        userdata: ?*Userdata,\n        comptime callback: *const fn (\n            ud: ?*Userdata,\n            conn: *Connection,\n            data: []const u8,\n            r: TCP.ReadError!usize,\n        ) void,\n    ) void {\n        const Context = struct {\n            conn: *Connection,\n            inner_callback: *const fn (\n                ud: ?*Userdata,\n                conn: *Connection,\n                data: []const u8,\n                r: TCP.ReadError!usize,\n            ) void,\n            userdata: ?*Userdata,\n        };\n\n        const ctx = Context{\n            .conn = self,\n            .inner_callback = callback,\n            .userdata = userdata,\n        };\n\n        self.tcp.read(\n            self.loop,\n            &self.completion,\n            .{ .slice = &self.buffer },\n            Context,\n            &ctx,\n            (struct {\n                fn callback(\n                    context: ?*Context,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: TCP,\n                    buf: xev.ReadBuffer,\n                    result: TCP.ReadError!usize,\n                ) xev.CallbackAction {\n                    const n = result catch |err| {\n                        context.?.inner_callback(\n                            context.?.userdata,\n                            context.?.conn,\n                            &[_]u8{},\n                            err,\n                        );\n                        return .disarm;\n                    };\n                    context.?.inner_callback(\n                        context.?.userdata,\n                        context.?.conn,\n                        buf.slice[0..n],\n                        result,\n                    );\n                    return .disarm;\n                }\n            }).callback,\n        );\n    }\n\n    pub fn write(\n        self: *Connection,\n        data: []const u8,\n        comptime Userdata: type,\n        userdata: ?*Userdata,\n        comptime callback: *const fn (\n            ud: ?*Userdata,\n            conn: *Connection,\n            r: TCP.WriteError!usize,\n        ) void,\n    ) void {\n        const Context = struct {\n            conn: *Connection,\n            inner_callback: *const fn (\n                ud: ?*Userdata,\n                conn: *Connection,\n                r: TCP.WriteError!usize,\n            ) void,\n            userdata: ?*Userdata,\n        };\n\n        const ctx = Context{\n            .conn = self,\n            .inner_callback = callback,\n            .userdata = userdata,\n        };\n\n        self.tcp.write(\n            self.loop,\n            &self.completion,\n            .{ .slice = data },\n            Context,\n            &ctx,\n            (struct {\n                fn callback(\n                    context: ?*Context,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: TCP,\n                    _: xev.WriteBuffer,\n                    result: TCP.WriteError!usize,\n                ) xev.CallbackAction {\n                    context.?.inner_callback(\n                        context.?.userdata,\n                        context.?.conn,\n                        result,\n                    );\n                    return .disarm;\n                }\n            }).callback,\n        );\n    }\n\n    pub fn close(self: *Connection) void {\n        self.tcp.close(\n            self.loop,\n            &self.completion,\n            void,\n            null,\n            (struct {\n                fn callback(\n                    _: ?*void,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: TCP,\n                    r: TCP.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch |err| {\n                        log.err(\"Error closing connection: {}\", .{err});\n                    };\n                    return .disarm;\n                }\n            }).callback,\n        );\n    }\n};\n```\n\nThis implementation:\n\n1. Creates a Connection struct that wraps the TCP socket, event loop, and a buffer for reading\n2. Provides wrapper functions for accept, read, write, and close operations\n3. Uses a simpler callback interface that focuses on the Connection rather than exposing the underlying xev types\n4. Maintains the asynchronous nature of the operations\n\nYou can use these wrappers like this:\n\n```zig\n// Example usage:\nfn handleNewConnection(ud: ?*void, conn: *Connection, result: TCP.AcceptError!TCP) void {\n    const client_conn = result catch |err| {\n        log.err(\"Accept error: {}\", .{err});\n        return;\n    };\n    \n    // Create new connection for client\n    var client = Connection.init(conn.server, client_conn, conn.loop);\n    \n    // Start reading from client\n    client.read(void, null, handleRead);\n}\n\nfn handleRead(ud: ?*void, conn: *Connection, data: []const u8, result: TCP.ReadError!usize) void {\n    const bytes_read = result catch |err| {\n        log.err(\"Read error: {}\", .{err});\n        conn.close();\n        return;\n    };\n\n    if (bytes_read == 0) {\n        conn.close();\n        return;\n    }\n\n    // Process data...\n    \n    // Write response\n    conn.write(response_data, void, null, handleWrite);\n}\n\nfn handleWrite(ud: ?*void, conn: *Connection, result: TCP.WriteError!usize) void {\n    _ = result catch |err| {\n        log.err(\"Write error: {}\", .{err});\n        conn.close();\n        return;\n    };\n\n    // Continue reading\n    conn.read(void, null, handleRead);\n}\n```\n\nThis wrapper makes it easier to handle TCP connections while still maintaining the event-driven nature of the xev library. The Connection struct encapsulates the common operations and provides a more straightforward interface for handling TCP connections.\nexplain what the inner callback does and how each function works\nI'll break down each function and explain how the callbacks work:\n\n1. **Accept Function**:\n```zig\npub fn accept(\n    self: *Connection,\n    comptime Userdata: type,\n    userdata: ?*Userdata,\n    comptime callback: *const fn (\n        ud: ?*Userdata,\n        conn: *Connection,\n        r: TCP.AcceptError!TCP,\n    ) void,\n) void {\n    // Context holds all the data needed for the inner callback\n    const Context = struct {\n        conn: *Connection,\n        inner_callback: *const fn (\n            ud: ?*Userdata,\n            conn: *Connection,\n            r: TCP.AcceptError!TCP,\n        ) void,\n        userdata: ?*Userdata,\n    };\n\n    // Create context with current state\n    const ctx = Context{\n        .conn = self,\n        .inner_callback = callback,\n        .userdata = userdata,\n    };\n\n    // Call TCP.accept with our wrapper callback\n    self.tcp.accept(\n        self.loop,\n        &self.completion,\n        Context,  // Type of userdata for inner callback\n        &ctx,     // Pass context as userdata\n        (struct {\n            fn callback(\n                context: ?*Context,\n                _: *xev.Loop,\n                _: *xev.Completion,\n                result: TCP.AcceptError!TCP,\n            ) xev.CallbackAction {\n                // Forward the result to user's callback\n                context.?.inner_callback(\n                    context.?.userdata,\n                    context.?.conn,\n                    result,\n                );\n                return .disarm;\n            }\n        }).callback,\n    );\n}\n```\nThe inner callback acts as a bridge between xev's callback system and our simplified interface. It:\n- Takes the low-level xev callback parameters\n- Extracts the context containing our high-level callback\n- Calls our high-level callback with the relevant parameters\n\n2. **Read Function**:\n```zig\npub fn read(\n    self: *Connection,\n    comptime Userdata: type,\n    userdata: ?*Userdata,\n    comptime callback: *const fn (\n        ud: ?*Userdata,\n        conn: *Connection,\n        data: []const u8,\n        r: TCP.ReadError!usize,\n    ) void,\n) void {\n    const Context = struct {\n        conn: *Connection,\n        inner_callback: *const fn (\n            ud: ?*Userdata,\n            conn: *Connection,\n            data: []const u8,\n            r: TCP.ReadError!usize,\n        ) void,\n        userdata: ?*Userdata,\n    };\n\n    const ctx = Context{ ... };\n\n    self.tcp.read(\n        self.loop,\n        &self.completion,\n        .{ .slice = &self.buffer },\n        Context,\n        &ctx,\n        (struct {\n            fn callback(\n                context: ?*Context,\n                _: *xev.Loop,\n                _: *xev.Completion,\n                _: TCP,\n                buf: xev.ReadBuffer,\n                result: TCP.ReadError!usize,\n            ) xev.CallbackAction {\n                // Handle read error\n                const n = result catch |err| {\n                    context.?.inner_callback(\n                        context.?.userdata,\n                        context.?.conn,\n                        &[_]u8{},\n                        err,\n                    );\n                    return .disarm;\n                };\n\n                // Forward successful read with data\n                context.?.inner_callback(\n                    context.?.userdata,\n                    context.?.conn,\n                    buf.slice[0..n],\n                    result,\n                );\n                return .disarm;\n            }\n        }).callback,\n    );\n}\n```\nThe read inner callback:\n- Handles read errors by passing an empty slice\n- On success, passes the actual read data to the user's callback\n- Provides both the data and the result for complete error handling\n\n3. **Write Function**:\n```zig\npub fn write(\n    self: *Connection,\n    data: []const u8,\n    comptime Userdata: type,\n    userdata: ?*Userdata,\n    comptime callback: *const fn (\n        ud: ?*Userdata,\n        conn: *Connection,\n        r: TCP.WriteError!usize,\n    ) void,\n) void {\n    const Context = struct {\n        conn: *Connection,\n        inner_callback: *const fn (\n            ud: ?*Userdata,\n            conn: *Connection,\n            r: TCP.WriteError!usize,\n        ) void,\n        userdata: ?*Userdata,\n    };\n\n    const ctx = Context{ ... };\n\n    self.tcp.write(\n        self.loop,\n        &self.completion,\n        .{ .slice = data },\n        Context,\n        &ctx,\n        (struct {\n            fn callback(\n                context: ?*Context,\n                _: *xev.Loop,\n                _: *xev.Completion,\n                _: TCP,\n                _: xev.WriteBuffer,\n                result: TCP.WriteError!usize,\n            ) xev.CallbackAction {\n                // Simply forward the write result\n                context.?.inner_callback(\n                    context.?.userdata,\n                    context.?.conn,\n                    result,\n                );\n                return .disarm;\n            }\n        }).callback,\n    );\n}\n```\nThe write inner callback:\n- Simply forwards the write result to the user's callback\n- Hides the complexity of the underlying xev interface\n\nCommon patterns across all functions:\n1. They create a Context struct to store:\n   - Reference to the Connection\n   - User's callback function\n   - User's custom data\n\n2. The inner callbacks:\n   - Access the stored context\n   - Transform xev's low-level interface into our higher-level one\n   - Handle errors appropriately\n   - Return .disarm to indicate completion\n\n3. The user interface is simplified to:\n   - Connection reference\n   - Optional user data\n   - Operation-specific data (like read/write buffers)\n   - Error handling through results\n\nThis abstraction makes it easier to work with the TCP connections while still maintaining the event-driven nature of xev. Users don't need to know about completions, loops, or the detailed xev interface - they just work with connections and their data.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":397}}},{"id":{"replica_id":0,"value":45},"start":29862,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":398}}},{"id":{"replica_id":0,"value":46},"start":37506,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":399}}},{"id":{"replica_id":0,"value":174},"start":37571,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":400}}},{"id":{"replica_id":0,"value":175},"start":43490,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":401}}}],"summary":"TCP Connection Event Loop Functions","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":23614},"icon":"File","label":"/home/msharran/.cache/zig/p/12205b2b47fe61a4cde3a45ee4b9cddee75897739dbc196d6396e117cb1ce28e1ad0/src/watcher/tcp.zig","metadata":{"path":"/home/msharran/.cache/zig/p/12205b2b47fe61a4cde3a45ee4b9cddee75897739dbc196d6396e117cb1ce28e1ad0/src/watcher/tcp.zig"}},{"range":{"start":23615,"end":29756},"icon":"File","label":"zig-redis-server/src/Server.zig","metadata":{"path":"zig-redis-server/src/Server.zig"}}]}