{"id":"b03b4ad7-ebbe-46e7-a318-d42a908ad48d","zed":"context","version":"0.4.0","text":"\n\n\n```zig zig-redis-server/src/TcpServer.zig\nconst std = @import(\"std\");\nconst log = std.log.scoped(.server);\nconst net = std.net;\nconst posix = std.posix;\n\nconst TcpServer = @This();\nconst Dictionary = @import(\"Dictionary.zig\");\nconst Router = @import(\"Router.zig\");\nconst Resp = @import(\"Resp.zig\");\nconst Request = @import(\"command.zig\").Request;\nconst ThreadPool = std.Thread.Pool;\nconst xev = @import(\"xev\");\nconst TCP = xev.TCP;\n\n/// router is responsible for handling the commands received by the server.\nrouter: Router,\n\n/// allocator is used to allocate memory for the server.\nallocator: std.mem.Allocator,\n\ndict: *Dictionary,\n\n/// pool is used to handle incoming connections concurrently.\npool: *ThreadPool,\n\n/// init allocates memory for the server.\n/// Caller should call self.deinit to free the memory.\npub fn init(allocator: std.mem.Allocator) !TcpServer {\n    const obj_store = try Dictionary.init(allocator);\n    const router = try Router.init(allocator);\n\n    const opt = ThreadPool.Options{\n        .n_jobs = 4, // TODO: Make this configurable\n        .allocator = allocator,\n    };\n    var pool = try allocator.create(ThreadPool);\n    try pool.init(opt);\n\n    return TcpServer{\n        .allocator = allocator,\n        .router = router,\n        .dict = obj_store,\n        .pool = pool,\n    };\n}\n\npub fn deinit(self: *TcpServer) void {\n    defer std.debug.print(\"Server deinitialised\", .{});\n\n    self.pool.deinit();\n    self.allocator.destroy(self.pool);\n    self.dict.deinit();\n    self.router.deinit();\n    self.* = undefined;\n}\n\npub fn listenAndServe(self: *TcpServer, address: std.net.Address) !void {\n    var loop = try xev.Loop.init(.{});\n    defer loop.deinit();\n\n    // Initialize TCP server\n    var tcp = try TCP.init(address);\n\n    // Bind and listen\n    try tcp.bind(address);\n    try tcp.listen(128);\n\n    // Accept loop\n    while (true) {\n        var a_completion: xev.Completion = undefined;\n        tcp.accept(&loop, &a_completion, void, null, acceptCallback);\n\n        // Run the event loop\n        try loop.run(.until_done);\n    }\n}\n\n/// handleConnection is reponsible for handling incoming connections.\n/// It reads from the client, deserialises the message, routes it to the appropriate handler,\n/// and writes the response back to the client.\n///\n/// Arguments:\n///     self: The server instance\n///     connection: The socket file descriptor for the client connection\n///\n/// Returns: void\nfn handleConnection(self: *TcpServer, connection: posix.socket_t) void {\n    defer posix.close(connection);\n\n    var buf: [4028]u8 = undefined;\n    const read = posix.read(connection, &buf) catch |err| {\n        log.err(\"Failed to read from client: {}\", .{err});\n        return;\n    };\n\n    if (read == 0) {\n        log.info(\"Read 0 bytes from client, closing connection\", .{});\n        return;\n    }\n\n    const resp = Resp.init(self.allocator);\n    defer resp.deinit();\n\n    const msg = resp.deserialise(buf[0..read]) catch |err| {\n        log.err(\"Failed to deserialise message: {}\", .{err});\n        return;\n    };\n\n    const req = Request{ .message = msg, .dict = self.dict };\n    const resp_msg = self.router.route(req);\n\n    const raw_msg = resp.serialise(resp_msg) catch |err| {\n        log.err(\"Failed to serialise message: {}\", .{err});\n        return;\n    };\n\n    writeAll(connection, raw_msg) catch |err| {\n        log.err(\"Failed to write to client: {}\", .{err});\n    };\n}\n\nfn writeAll(socket: posix.socket_t, msg: []const u8) !void {\n    var pos: usize = 0;\n    while (pos < msg.len) {\n        const written = try posix.write(socket, msg[pos..]);\n        if (written == 0) {\n            return error.Closed;\n        }\n        pos += written;\n    }\n}\n\n```\n\n```zig /home/msharran/.cache/zig/p/12205b2b47fe61a4cde3a45ee4b9cddee75897739dbc196d6396e117cb1ce28e1ad0/src/watcher/tcp.zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst assert = std.debug.assert;\nconst posix = std.posix;\nconst stream = @import(\"stream.zig\");\nconst common = @import(\"common.zig\");\n\n/// TCP client and server.\n///\n/// This is a \"higher-level abstraction\" in libxev. The goal of higher-level\n/// abstractions in libxev are to make it easier to use specific functionality\n/// with the event loop, but does not promise perfect flexibility or optimal\n/// performance. In almost all cases, the abstraction is good enough. But,\n/// if you have specific needs or want to push for the most optimal performance,\n/// use the platform-specific Loop directly.\npub fn TCP(comptime xev: type) type {\n    return struct {\n        const Self = @This();\n        const FdType = if (xev.backend == .iocp) std.os.windows.HANDLE else posix.socket_t;\n\n        fd: FdType,\n\n        pub usingnamespace stream.Stream(xev, Self, .{\n            .close = true,\n            .read = .recv,\n            .write = .send,\n        });\n\n        /// Initialize a new TCP with the family from the given address. Only\n        /// the family is used, the actual address has no impact on the created\n        /// resource.\n        pub fn init(addr: std.net.Address) !Self {\n            if (xev.backend == .wasi_poll) @compileError(\"unsupported in WASI\");\n\n            const fd = if (xev.backend == .iocp)\n                try std.os.windows.WSASocketW(addr.any.family, posix.SOCK.STREAM, 0, null, 0, std.os.windows.ws2_32.WSA_FLAG_OVERLAPPED)\n            else fd: {\n                // On io_uring we don't use non-blocking sockets because we may\n                // just get EAGAIN over and over from completions.\n                const flags = flags: {\n                    var flags: u32 = posix.SOCK.STREAM | posix.SOCK.CLOEXEC;\n                    if (xev.backend != .io_uring) flags |= posix.SOCK.NONBLOCK;\n                    break :flags flags;\n                };\n                break :fd try posix.socket(addr.any.family, flags, 0);\n            };\n\n            return .{\n                .fd = fd,\n            };\n        }\n\n        /// Initialize a TCP socket from a file descriptor.\n        pub fn initFd(fd: FdType) Self {\n            return .{\n                .fd = fd,\n            };\n        }\n\n        /// Bind the address to the socket.\n        pub fn bind(self: Self, addr: std.net.Address) !void {\n            if (xev.backend == .wasi_poll) @compileError(\"unsupported in WASI\");\n\n            const fd = if (xev.backend == .iocp) @as(std.os.windows.ws2_32.SOCKET, @ptrCast(self.fd)) else self.fd;\n\n            try posix.setsockopt(fd, posix.SOL.SOCKET, posix.SO.REUSEADDR, &std.mem.toBytes(@as(c_int, 1)));\n            try posix.bind(fd, &addr.any, addr.getOsSockLen());\n        }\n\n        /// Listen for connections on the socket. This puts the socket into passive\n        /// listening mode. Connections must still be accepted one at a time.\n        pub fn listen(self: Self, backlog: u31) !void {\n            if (xev.backend == .wasi_poll) @compileError(\"unsupported in WASI\");\n\n            const fd = if (xev.backend == .iocp) @as(std.os.windows.ws2_32.SOCKET, @ptrCast(self.fd)) else self.fd;\n\n            try posix.listen(fd, backlog);\n        }\n\n        /// Accept a single connection.\n        pub fn accept(\n            self: Self,\n            loop: *xev.Loop,\n            c: *xev.Completion,\n            comptime Userdata: type,\n            userdata: ?*Userdata,\n            comptime cb: *const fn (\n                ud: ?*Userdata,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                r: AcceptError!Self,\n            ) xev.CallbackAction,\n        ) void {\n            c.* = .{\n                .op = .{\n                    .accept = .{\n                        .socket = self.fd,\n                    },\n                },\n\n                .userdata = userdata,\n                .callback = (struct {\n                    fn callback(\n                        ud: ?*anyopaque,\n                        l_inner: *xev.Loop,\n                        c_inner: *xev.Completion,\n                        r: xev.Result,\n                    ) xev.CallbackAction {\n                        return @call(.always_inline, cb, .{\n                            common.userdataValue(Userdata, ud),\n                            l_inner,\n                            c_inner,\n                            if (r.accept) |fd| initFd(fd) else |err| err,\n                        });\n                    }\n                }).callback,\n            };\n\n            // If we're dup-ing, then we ask the backend to manage the fd.\n            switch (xev.backend) {\n                .io_uring,\n                .kqueue,\n                .wasi_poll,\n                .iocp,\n                => {},\n\n                .epoll => c.flags.dup = true,\n            }\n\n            loop.add(c);\n        }\n\n        /// Establish a connection as a client.\n        pub fn connect(\n            self: Self,\n            loop: *xev.Loop,\n            c: *xev.Completion,\n            addr: std.net.Address,\n            comptime Userdata: type,\n            userdata: ?*Userdata,\n            comptime cb: *const fn (\n                ud: ?*Userdata,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: Self,\n                r: ConnectError!void,\n            ) xev.CallbackAction,\n        ) void {\n            if (xev.backend == .wasi_poll) @compileError(\"unsupported in WASI\");\n\n            c.* = .{\n                .op = .{\n                    .connect = .{\n                        .socket = self.fd,\n                        .addr = addr,\n                    },\n                },\n\n                .userdata = userdata,\n                .callback = (struct {\n                    fn callback(\n                        ud: ?*anyopaque,\n                        l_inner: *xev.Loop,\n                        c_inner: *xev.Completion,\n                        r: xev.Result,\n                    ) xev.CallbackAction {\n                        return @call(.always_inline, cb, .{\n                            common.userdataValue(Userdata, ud),\n                            l_inner,\n                            c_inner,\n                            initFd(c_inner.op.connect.socket),\n                            if (r.connect) |_| {} else |err| err,\n                        });\n                    }\n                }).callback,\n            };\n\n            loop.add(c);\n        }\n\n        /// Shutdown the socket. This always only shuts down the writer side. You\n        /// can use the lower level interface directly to control this if the\n        /// platform supports it.\n        pub fn shutdown(\n            self: Self,\n            loop: *xev.Loop,\n            c: *xev.Completion,\n            comptime Userdata: type,\n            userdata: ?*Userdata,\n            comptime cb: *const fn (\n                ud: ?*Userdata,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: Self,\n                r: ShutdownError!void,\n            ) xev.CallbackAction,\n        ) void {\n            c.* = .{\n                .op = .{\n                    .shutdown = .{\n                        .socket = self.fd,\n                        .how = .send,\n                    },\n                },\n                .userdata = userdata,\n                .callback = (struct {\n                    fn callback(\n                        ud: ?*anyopaque,\n                        l_inner: *xev.Loop,\n                        c_inner: *xev.Completion,\n                        r: xev.Result,\n                    ) xev.CallbackAction {\n                        return @call(.always_inline, cb, .{\n                            common.userdataValue(Userdata, ud),\n                            l_inner,\n                            c_inner,\n                            initFd(c_inner.op.shutdown.socket),\n                            if (r.shutdown) |_| {} else |err| err,\n                        });\n                    }\n                }).callback,\n            };\n\n            loop.add(c);\n        }\n\n        pub const AcceptError = xev.AcceptError;\n        pub const ConnectError = xev.ConnectError;\n        pub const ShutdownError = xev.ShutdownError;\n\n        test \"TCP: accept/connect/send/recv/close\" {\n            // We have no way to get a socket in WASI from a WASI context.\n            if (xev.backend == .wasi_poll) return error.SkipZigTest;\n\n            const testing = std.testing;\n\n            var loop = try xev.Loop.init(.{});\n            defer loop.deinit();\n\n            // Choose random available port (Zig #14907)\n            var address = try std.net.Address.parseIp4(\"127.0.0.1\", 0);\n            const server = try Self.init(address);\n\n            // Bind and listen\n            try server.bind(address);\n            try server.listen(1);\n\n            // Retrieve bound port and initialize client\n            var sock_len = address.getOsSockLen();\n            const fd = if (xev.backend == .iocp) @as(std.os.windows.ws2_32.SOCKET, @ptrCast(server.fd)) else server.fd;\n            try posix.getsockname(fd, &address.any, &sock_len);\n            const client = try Self.init(address);\n\n            //const address = try std.net.Address.parseIp4(\"127.0.0.1\", 3132);\n            //var server = try Self.init(address);\n            //var client = try Self.init(address);\n\n            // Completions we need\n            var c_accept: xev.Completion = undefined;\n            var c_connect: xev.Completion = undefined;\n\n            // Accept\n            var server_conn: ?Self = null;\n            server.accept(&loop, &c_accept, ?Self, &server_conn, (struct {\n                fn callback(\n                    ud: ?*?Self,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    r: AcceptError!Self,\n                ) xev.CallbackAction {\n                    ud.?.* = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Connect\n            var connected: bool = false;\n            client.connect(&loop, &c_connect, address, bool, &connected, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: ConnectError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = true;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Wait for the connection to be established\n            try loop.run(.until_done);\n            try testing.expect(server_conn != null);\n            try testing.expect(connected);\n\n            // Close the server\n            var server_closed = false;\n            server.close(&loop, &c_accept, bool, &server_closed, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = true;\n                    return .disarm;\n                }\n            }).callback);\n            try loop.run(.until_done);\n            try testing.expect(server_closed);\n\n            // Send\n            var send_buf = [_]u8{ 1, 1, 2, 3, 5, 8, 13 };\n            client.write(&loop, &c_connect, .{ .slice = &send_buf }, void, null, (struct {\n                fn callback(\n                    _: ?*void,\n                    _: *xev.Loop,\n                    c: *xev.Completion,\n                    _: Self,\n                    _: xev.WriteBuffer,\n                    r: Self.WriteError!usize,\n                ) xev.CallbackAction {\n                    _ = c;\n                    _ = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Receive\n            var recv_buf: [128]u8 = undefined;\n            var recv_len: usize = 0;\n            server_conn.?.read(&loop, &c_accept, .{ .slice = &recv_buf }, usize, &recv_len, (struct {\n                fn callback(\n                    ud: ?*usize,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    _: xev.ReadBuffer,\n                    r: Self.ReadError!usize,\n                ) xev.CallbackAction {\n                    ud.?.* = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Wait for the send/receive\n            try loop.run(.until_done);\n            try testing.expectEqualSlices(u8, &send_buf, recv_buf[0..recv_len]);\n\n            // Close\n            server_conn.?.close(&loop, &c_accept, ?Self, &server_conn, (struct {\n                fn callback(\n                    ud: ?*?Self,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = null;\n                    return .disarm;\n                }\n            }).callback);\n            client.close(&loop, &c_connect, bool, &connected, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = false;\n                    return .disarm;\n                }\n            }).callback);\n\n            try loop.run(.until_done);\n            try testing.expect(server_conn == null);\n            try testing.expect(!connected);\n            try testing.expect(server_closed);\n        }\n\n        // Potentially flaky - this test could hang if the sender is unable to\n        // write everything to the socket for whatever reason\n        // (e.g. incorrectly sized buffer on the receiver side), or if the\n        // receiver is trying to receive while sender has nothing left to send.\n        //\n        // Overview:\n        // 1. Set up server and client sockets\n        // 2. connect & accept, set SO_SNDBUF to 8kB on the client\n        // 3. Try to send 1MB buffer from client to server without queuing, this _should_ fail\n        //    and theoretically send <= 8kB, but in practice, it seems to write ~32kB.\n        //    Asserts that <= 100kB was written\n        // 4. Set up a queued write with the remaining buffer, shutdown() the socket afterwards\n        // 5. Set up a receiver that loops until it receives the entire buffer\n        // 6. Assert send_buf == recv_buf\n        test \"TCP: Queued writes\" {\n            // We have no way to get a socket in WASI from a WASI context.\n            if (xev.backend == .wasi_poll) return error.SkipZigTest;\n            // Windows doesn't seem to respect the SNDBUF socket option.\n            if (builtin.os.tag == .windows) return error.SkipZigTest;\n\n            const testing = std.testing;\n\n            var loop = try xev.Loop.init(.{});\n            defer loop.deinit();\n\n            // Choose random available port (Zig #14907)\n            var address = try std.net.Address.parseIp4(\"127.0.0.1\", 0);\n            const server = try Self.init(address);\n\n            // Bind and listen\n            try server.bind(address);\n            try server.listen(1);\n\n            // Retrieve bound port and initialize client\n            var sock_len = address.getOsSockLen();\n            try posix.getsockname(server.fd, &address.any, &sock_len);\n            const client = try Self.init(address);\n\n            // Completions we need\n            var c_accept: xev.Completion = undefined;\n            var c_connect: xev.Completion = undefined;\n\n            // Accept\n            var server_conn: ?Self = null;\n            server.accept(&loop, &c_accept, ?Self, &server_conn, (struct {\n                fn callback(\n                    ud: ?*?Self,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    r: AcceptError!Self,\n                ) xev.CallbackAction {\n                    ud.?.* = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Connect\n            var connected: bool = false;\n            client.connect(&loop, &c_connect, address, bool, &connected, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: ConnectError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = true;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Wait for the connection to be established\n            try loop.run(.until_done);\n            try testing.expect(server_conn != null);\n            try testing.expect(connected);\n\n            // Close the server\n            var server_closed = false;\n            server.close(&loop, &c_accept, bool, &server_closed, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = true;\n                    return .disarm;\n                }\n            }).callback);\n            try loop.run(.until_done);\n            try testing.expect(server_closed);\n\n            // Unqueued send - Limit send buffer to 8kB, this should force partial writes.\n            try posix.setsockopt(client.fd, posix.SOL.SOCKET, posix.SO.SNDBUF, &std.mem.toBytes(@as(c_int, 8192)));\n\n            const send_buf = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 } ** 100_000;\n            var sent_unqueued: usize = 0;\n\n            // First we try to send the whole 1MB buffer in one write operation, this _should_ result\n            // in a partial write.\n            client.write(&loop, &c_connect, .{ .slice = &send_buf }, usize, &sent_unqueued, (struct {\n                fn callback(\n                    sent_unqueued_inner: ?*usize,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    _: xev.WriteBuffer,\n                    r: Self.WriteError!usize,\n                ) xev.CallbackAction {\n                    sent_unqueued_inner.?.* = r catch unreachable;\n                    return .disarm;\n                }\n            }).callback);\n\n            // Make sure that we sent a small fraction of the buffer\n            try loop.run(.until_done);\n            // SO_SNDBUF doesn't seem to be respected exactly, sent_unqueued will often be ~32kB\n            // even though SO_SNDBUF was set to 8kB\n            try testing.expect(sent_unqueued < (send_buf.len / 10));\n\n            // Set up queued write\n            var w_queue = Self.WriteQueue{};\n            var wr_send: xev.TCP.WriteRequest = undefined;\n            var sent_queued: usize = 0;\n            const queued_slice = send_buf[sent_unqueued..];\n            client.queueWrite(&loop, &w_queue, &wr_send, .{ .slice = queued_slice }, usize, &sent_queued, (struct {\n                fn callback(\n                    sent_queued_inner: ?*usize,\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    tcp: Self,\n                    _: xev.WriteBuffer,\n                    r: Self.WriteError!usize,\n                ) xev.CallbackAction {\n                    sent_queued_inner.?.* = r catch unreachable;\n\n                    tcp.shutdown(l, c, void, null, (struct {\n                        fn callback(\n                            _: ?*void,\n                            _: *xev.Loop,\n                            _: *xev.Completion,\n                            _: Self,\n                            _: Self.ShutdownError!void,\n                        ) xev.CallbackAction {\n                            return .disarm;\n                        }\n                    }).callback);\n\n                    return .disarm;\n                }\n            }).callback);\n\n            // Set up receiver which is going to keep reading until it reads the full\n            // send buffer\n            const Receiver = struct {\n                loop: *xev.Loop,\n                conn: Self,\n                completion: xev.Completion = .{},\n                buf: [send_buf.len]u8 = undefined,\n                bytes_read: usize = 0,\n\n                pub fn read(receiver: *@This()) void {\n                    if (receiver.bytes_read == receiver.buf.len) return;\n\n                    const read_buf = xev.ReadBuffer{\n                        .slice = receiver.buf[receiver.bytes_read..],\n                    };\n                    receiver.conn.read(receiver.loop, &receiver.completion, read_buf, @This(), receiver, readCb);\n                }\n\n                pub fn readCb(\n                    receiver_opt: ?*@This(),\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    _: xev.ReadBuffer,\n                    r: Self.ReadError!usize,\n                ) xev.CallbackAction {\n                    var receiver = receiver_opt.?;\n                    const n_bytes = r catch unreachable;\n\n                    receiver.bytes_read += n_bytes;\n                    if (receiver.bytes_read < send_buf.len) {\n                        receiver.read();\n                    }\n\n                    return .disarm;\n                }\n            };\n            var receiver = Receiver{\n                .loop = &loop,\n                .conn = server_conn.?,\n            };\n            receiver.read();\n\n            // Wait for the send/receive\n            try loop.run(.until_done);\n            try testing.expectEqualSlices(u8, &send_buf, receiver.buf[0..receiver.bytes_read]);\n            try testing.expect(send_buf.len == sent_unqueued + sent_queued);\n\n            // Close\n            server_conn.?.close(&loop, &c_accept, ?Self, &server_conn, (struct {\n                fn callback(\n                    ud: ?*?Self,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = null;\n                    return .disarm;\n                }\n            }).callback);\n            client.close(&loop, &c_connect, bool, &connected, (struct {\n                fn callback(\n                    ud: ?*bool,\n                    _: *xev.Loop,\n                    _: *xev.Completion,\n                    _: Self,\n                    r: Self.CloseError!void,\n                ) xev.CallbackAction {\n                    _ = r catch unreachable;\n                    ud.?.* = false;\n                    return .disarm;\n                }\n            }).callback);\n\n            try loop.run(.until_done);\n            try testing.expect(server_conn == null);\n            try testing.expect(!connected);\n            try testing.expect(server_closed);\n        }\n    };\n}\n```\n\n\ngenerate acceptCallback function code for simple echo server using xev.TCP.accept function\n\n\nBased on the TCP implementation shown, here's how you can implement the acceptCallback function for a simple echo server:\n\n```zig\nfn acceptCallback(\n    _: ?*void,\n    loop: *xev.Loop,\n    completion: *xev.Completion,\n    result: xev.TCP.AcceptError!xev.TCP,\n) xev.CallbackAction {\n    // Handle accept errors\n    const client_conn = result catch |err| {\n        log.err(\"Accept error: {}\", .{err});\n        return .disarm;\n    };\n\n    // Buffer for reading data\n    var read_buf: [4096]u8 = undefined;\n    var read_completion: xev.Completion = undefined;\n\n    // Setup read from client\n    client_conn.read(\n        loop, \n        &read_completion,\n        .{ .slice = &read_buf },\n        xev.TCP,\n        client_conn,\n        readCallback,\n    );\n\n    // Accept more connections\n    // completion.op.accept.socket.accept(\n    //     loop,\n    //     completion,\n    //     void,\n    //     null,\n    //     acceptCallback,\n    // );\n\n    return .rearm;\n}\n\nfn readCallback(\n    client_conn_ptr: ?*xev.TCP,\n    loop: *xev.Loop, \n    completion: *xev.Completion,\n    _: xev.TCP,\n    buffer: xev.ReadBuffer,\n    result: xev.TCP.ReadError!usize,\n) xev.CallbackAction {\n    const client_conn = client_conn_ptr.?;\n    \n    // Handle read errors\n    const bytes_read = result catch |err| {\n        log.err(\"Read error: {}\", .{err});\n        client_conn.close(loop, completion, void, null, closeCallback);\n        return .disarm;\n    };\n\n    // Check for EOF\n    if (bytes_read == 0) {\n        client_conn.close(loop, completion, void, null, closeCallback);\n        return .disarm;\n    }\n\n    // Echo the data back\n    const write_buf = buffer.slice[0..bytes_read];\n    client_conn.write(\n        loop,\n        completion, \n        .{ .slice = write_buf },\n        xev.TCP,\n        client_conn,\n        writeCallback,\n    );\n\n    return .disarm;\n}\n\nfn writeCallback(\n    client_conn_ptr: ?*xev.TCP,\n    loop: *xev.Loop,\n    completion: *xev.Completion,\n    _: xev.TCP,\n    _: xev.WriteBuffer,\n    result: xev.TCP.WriteError!usize,\n) xev.CallbackAction {\n    const client_conn = client_conn_ptr.?;\n\n    // Handle write errors\n    _ = result catch |err| {\n        log.err(\"Write error: {}\", .{err});\n        client_conn.close(loop, completion, void, null, closeCallback);\n        return .disarm;\n    };\n\n    // Setup next read\n    var read_buf: [4096]u8 = undefined;\n    client_conn.read(\n        loop,\n        completion,\n        .{ .slice = &read_buf },\n        xev.TCP,\n        client_conn,\n        readCallback,\n    );\n\n    return .disarm;\n}\n\nfn closeCallback(\n    _: ?*void,\n    _: *xev.Loop,\n    _: *xev.Completion,\n    _: xev.TCP,\n    result: xev.TCP.CloseError!void,\n) xev.CallbackAction {\n    if (result) {} else |err| {\n        log.err(\"Close error: {}\", .{err});\n    }\n    return .disarm;\n}\n```\n\nThis implementation:\n\n1. acceptCallback:\n   - Accepts new connections\n   - Sets up reading from the new client\n   - Rearms itself to accept more connections\n\n2. readCallback:\n   - Reads data from the client\n   - If there's an error or EOF, closes the connection\n   - Otherwise echoes the data back using write\n\n3. writeCallback:\n   - Handles write completion\n   - Sets up the next read\n   - Closes connection on error\n\n4. closeCallback:\n   - Handles connection cleanup\n\nThe callbacks chain together to create an event loop that:\n1. Accepts connections\n2. Reads data from clients \n3. Echoes data back\n4. Repeats until client disconnects\n\nYou would use this with your TCP server like:\n\n```zig\npub fn listenAndServe(self: *TcpServer, address: std.net.Address) !void {\n    var loop = try xev.Loop.init(.{});\n    defer loop.deinit();\n\n    var tcp = try xev.TCP.init(address); \n    try tcp.bind(address);\n    try tcp.listen(128);\n\n    while (true) {\n        var completion: xev.Completion = undefined;\n        tcp.accept(&loop, &completion, void, null, acceptCallback);\n        try loop.run(.until_done);\n    }\n}\n```\n\nThis provides a basic echo server implementation using xev's event loop and TCP abstraction.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":245}}},{"id":{"replica_id":0,"value":78},"start":27404,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":246}}},{"id":{"replica_id":0,"value":79},"start":31408,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":247}}}],"summary":"TCP Accept Callback Implementation","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":3697},"icon":"File","label":"zig-redis-server/src/TcpServer.zig","metadata":{"path":"zig-redis-server/src/TcpServer.zig"}},{"range":{"start":3698,"end":27309},"icon":"File","label":"/home/msharran/.cache/zig/p/12205b2b47fe61a4cde3a45ee4b9cddee75897739dbc196d6396e117cb1ce28e1ad0/src/watcher/tcp.zig","metadata":{"path":"/home/msharran/.cache/zig/p/12205b2b47fe61a4cde3a45ee4b9cddee75897739dbc196d6396e117cb1ce28e1ad0/src/watcher/tcp.zig"}}]}